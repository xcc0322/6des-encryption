## -*- coding: cp437 -*-
#----------------------------------------------------------------------------
# Name:         DES_Encryptor.py
# Purpose:      [PJ 1.1]An implementation for DES encryption and decryption.
#               6 times in CBC way.
#               GUI in wxPython.
# Author:       Chengcheng Xu
#
# Created:      2013.10.8
#----------------------------------------------------------------------------
from functools import partial
import random

NUMBER_OF_ROUNDS = 6

class FeistelFunctionImplement:
    __s = [  
        [  
        0xe,0x4,0xd,0x1,0x2,0xf,0xb,0x8,0x3,0xa,0x6,0xc,0x5,0x9,0x0,0x7,  
        0x0,0xf,0x7,0x4,0xe,0x2,0xd,0x1,0xa,0x6,0xc,0xb,0x9,0x5,0x3,0x8,  
        0x4,0x1,0xe,0x8,0xd,0x6,0x2,0xb,0xf,0xc,0x9,0x7,0x3,0xa,0x5,0x0,  
        0xf,0xc,0x8,0x2,0x4,0x9,0x1,0x7,0x5,0xb,0x3,0xe,0xa,0x0,0x6,0xd,  
        ],  
        [  
        0xf,0x1,0x8,0xe,0x6,0xb,0x3,0x4,0x9,0x7,0x2,0xd,0xc,0x0,0x5,0xa,  
        0x3,0xd,0x4,0x7,0xf,0x2,0x8,0xe,0xc,0x0,0x1,0xa,0x6,0x9,0xb,0x5,  
        0x0,0xe,0x7,0xb,0xa,0x4,0xd,0x1,0x5,0x8,0xc,0x6,0x9,0x3,0x2,0xf,  
        0xd,0x8,0xa,0x1,0x3,0xf,0x4,0x2,0xb,0x6,0x7,0xc,0x0,0x5,0xe,0x9,  
        ],  
        [  
        0xa,0x0,0x9,0xe,0x6,0x3,0xf,0x5,0x1,0xd,0xc,0x7,0xb,0x4,0x2,0x8,  
        0xd,0x7,0x0,0x9,0x3,0x4,0x6,0xa,0x2,0x8,0x5,0xe,0xc,0xb,0xf,0x1,  
        0xd,0x6,0x4,0x9,0x8,0xf,0x3,0x0,0xb,0x1,0x2,0xc,0x5,0xa,0xe,0x7,  
        0x1,0xa,0xd,0x0,0x6,0x9,0x8,0x7,0x4,0xf,0xe,0x3,0xb,0x5,0x2,0xc,  
        ],  
        [  
        0x7,0xd,0xe,0x3,0x0,0x6,0x9,0xa,0x1,0x2,0x8,0x5,0xb,0xc,0x4,0xf,  
        0xd,0x8,0xb,0x5,0x6,0xf,0x0,0x3,0x4,0x7,0x2,0xc,0x1,0xa,0xe,0x9,  
        0xa,0x6,0x9,0x0,0xc,0xb,0x7,0xd,0xf,0x1,0x3,0xe,0x5,0x2,0x8,0x4,  
        0x3,0xf,0x0,0x6,0xa,0x1,0xd,0x8,0x9,0x4,0x5,0xb,0xc,0x7,0x2,0xe,  
        ],  
        [  
        0x2,0xc,0x4,0x1,0x7,0xa,0xb,0x6,0x8,0x5,0x3,0xf,0xd,0x0,0xe,0x9,  
        0xe,0xb,0x2,0xc,0x4,0x7,0xd,0x1,0x5,0x0,0xf,0xa,0x3,0x9,0x8,0x6,  
        0x4,0x2,0x1,0xb,0xa,0xd,0x7,0x8,0xf,0x9,0xc,0x5,0x6,0x3,0x0,0xe,  
        0xb,0x8,0xc,0x7,0x1,0xe,0x2,0xd,0x6,0xf,0x0,0x9,0xa,0x4,0x5,0x3,  
        ],  
        [  
        0xc,0x1,0xa,0xf,0x9,0x2,0x6,0x8,0x0,0xd,0x3,0x4,0xe,0x7,0x5,0xb,  
        0xa,0xf,0x4,0x2,0x7,0xc,0x9,0x5,0x6,0x1,0xd,0xe,0x0,0xb,0x3,0x8,  
        0x9,0xe,0xf,0x5,0x2,0x8,0xc,0x3,0x7,0x0,0x4,0xa,0x1,0xd,0xb,0x6,  
        0x4,0x3,0x2,0xc,0x9,0x5,0xf,0xa,0xb,0xe,0x1,0x7,0x6,0x0,0x8,0xd,  
        ],  
        [  
        0x4,0xb,0x2,0xe,0xf,0x0,0x8,0xd,0x3,0xc,0x9,0x7,0x5,0xa,0x6,0x1,  
        0xd,0x0,0xb,0x7,0x4,0x9,0x1,0xa,0xe,0x3,0x5,0xc,0x2,0xf,0x8,0x6,  
        0x1,0x4,0xb,0xd,0xc,0x3,0x7,0xe,0xa,0xf,0x6,0x8,0x0,0x5,0x9,0x2,  
        0x6,0xb,0xd,0x8,0x1,0x4,0xa,0x7,0x9,0x5,0x0,0xf,0xe,0x2,0x3,0xc,  
        ],  
        [  
        0xd,0x2,0x8,0x4,0x6,0xf,0xb,0x1,0xa,0x9,0x3,0xe,0x5,0x0,0xc,0x7,  
        0x1,0xf,0xd,0x8,0xa,0x3,0x7,0x4,0xc,0x5,0x6,0xb,0x0,0xe,0x9,0x2,  
        0x7,0xb,0x4,0x1,0x9,0xc,0xe,0x2,0x0,0x6,0xa,0xd,0xf,0x3,0x5,0x8,  
        0x2,0x1,0xe,0x7,0x4,0xa,0x8,0xd,0xf,0xc,0x9,0x0,0x3,0x5,0x6,0xb,  
        ],
    ]
    __e = [
        32, 1, 2, 3, 4, 5,  
        4 , 5, 6, 7, 8, 9,  
        8 , 9,10,11,12,13,  
        12,13,14,15,16,17,  
        16,17,18,19,20,21,  
        20,21,22,23,24,25,  
        24,25,26,27,28,29,  
        28,29,30,31,32, 1,  
    ]
    __p = [  
        16, 7,20,21,29,12,28,17,  
        1 ,15,23,26, 5,18,31,10,  
        2 ,8 ,24,14,32,27, 3, 9,  
        19,13,30, 6,22,11, 4,25,  
    ]
    
    __hex_bin = {  
        '0':'0000','1':'0001','2':'0010','3':'0011', 
        '4':'0100','5':'0101','6':'0110','7':'0111',  
        '8':'1000','9':'1001','a':'1010','b':'1011',  
        'c':'1100','d':'1101','e':'1110','f':'1111', ' ':'0000'
    }
    __re = lambda t, s: ''.join(s[i-1] for i in t)
    __XOR = partial( lambda s, k: ''.join('0' if s[i]==k[i] else '1' for i in range(len(s))))  
    __E = partial(__re, __e)  
    __P = partial(__re, __p)

    def SBox(self, S):
        SBox_output = []
        print S
        for i in range(0, 48, 6):
            s = S[i:i+6]
            h1 = int(s[0] + s[5], 2)
            h2 = int(s[1:5], 2)
            SBox_output.append(self.__hex_bin["%1x" % self.__s[i/6][h1*16 + h2]])
        return ''.join(SBox_output)

    def FeistelFunction(self, R, K):
        S = self.__XOR(self.__E(R), K)
        return self.__P(self.SBox(S))

class SubKeyGenerator:
    __ipc = [  
        57,49,41,33,25,17, 9,  
        1 ,58,50,42,34,26,18,  
        10, 2,59,51,43,35,27,  
        19,11, 3,60,52,44,36,  
        63,55,47,39,31,23,15,  
        7 ,62,54,46,38,30,22,  
        14, 6,61,53,45,37,29,  
        21,13, 5,28,20,12, 4,  
    ]
    __pc = [  
        14,17,11,24, 1, 5, 3,28,  
        15, 6,21,10,23,19,12, 4,  
        26, 8,16, 7,27,20,13, 2,  
        41,52,31,37,47,55,30,40,  
        51,45,33,48,44,49,39,56,  
        34,53,46,42,50,36,29,32,  
    ]
    __ls = [  
        1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1,
    ]
    
    __re = lambda t, s: ''.join(s[i-1] for i in t)
    __IPC = partial(__re, __ipc)
    __PC = partial(__re, __pc)

    def __init__(self, key):
        # key is supposed to be a 56-bit binary string.
        self.key = key

    def Generate(self):
        #IPC
        self.key = SubKeyGenerator.__IPC(self.key)
        sub_keys = []

        #LS
        for i in range(NUMBER_OF_ROUNDS):
            k = self.key
            ls = self.__ls
            self.key = k[ls[i]:28] + k[0:ls[i]] + k[ls[i]+28:56] + k[28:ls[i]+28]
            #PC
            sub_keys.append(self.__PC(k))
        return sub_keys

class DesEncryptor:
    __ip = [
        58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,
        62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,
        57,49,41,33,25,17, 9,1,59,51,43,35,27,19,11,3,
        61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7,
    ] 
    __ip1 = [  
        40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,  
        38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,  
        36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,  
        34,2,42,10,50,18,58,26,33,1,41, 9,49,17,57,25,  
    ]
  
    __re = lambda t, s: ''.join(s[i-1] for i in t)
    __XOR = partial( lambda s, k: ''.join('0' if s[i]==k[i] else '1' for i in range(len(s))))  
    __IP = partial(__re, __ip)
    __IP1 = partial(__re, __ip1)
    __hex_bin = {  
        '0':'0000','1':'0001','2':'0010','3':'0011', 
        '4':'0100','5':'0101','6':'0110','7':'0111',  
        '8':'1000','9':'1001','a':'1010','b':'1011',  
        'c':'1100','d':'1101','e':'1110','f':'1111', ' ':'0000'
    }

    __DB = partial( lambda s: ''.join(chr(int(s[i:i+8], 2)) for i in range(0, len(s), 8)))  


    def __init__(self, key):
        self.keys = SubKeyGenerator(key).Generate()
        self.cbc_iv = ''.join("0" if random.random() < 0.5 else "1" for i in range(64))

    def DivideCipherTextsTo64Texts(self, input_string):
        binary_string = ''.join([self.__hex_bin[c] for c in input_string])
        texts = [binary_string[i:i+64] for i in range(0, len(binary_string), 64)]
        return texts

    def DividePlainTextsTo64Texts(self, input_string):
	makeup = 7 - len(input_string) % 8
	if(makeup < 0):
	    makeup += 8
        o_strings = ["%2x" % ord(c) for c in input_string]
        o_string = ''.join(o_strings)
        binary_string = (''.join([self.__hex_bin[c] for c in o_string]) +
			''.join("0" if random.random() < 0.5 else "1" for i in range(8*makeup)) +
			"0000" + self.__hex_bin["%d" % makeup])
        texts = [binary_string[i:i+64] for i in range(0, len(binary_string), 64)]
        return texts

    def Des(self, text):
        L0R0 = self.__IP(text)
        L = L0R0[0:32]
        R = L0R0[32:64]
        for key in self.keys:
            L_ = R
            R_ = self.__XOR(FeistelFunctionImplement().FeistelFunction(R, key), L)
            L = L_
            R = R_
        return self.__IP1(R+L)

    def Encrypt(self, input_string): 
	# Add the IV at the beginning of the cipher text
        cipher_texts = [self.Des(self.cbc_iv)]
	print "IV"
	print self.cbc_iv
	print  cipher_texts
        plain_texts = self.DividePlainTextsTo64Texts(input_string)
        #CBC Initialization Vector
	last_code = self.cbc_iv
        for text in plain_texts:
            text = self.__XOR(text, last_code)
            last_code = self.Des(text)
            cipher_texts.append(last_code)
        cipher_text = ''.join(cipher_texts)
        
        print cipher_text
        output_chars = []
	#output_chars = []
        for i in range(0, len(cipher_text), 8):
            print int(cipher_text[i:i+8],2)
            print chr(int(cipher_text[i:i+8],2))
            print 
            output_chars.append("%02x" % int(cipher_text[i:i+8],2))
        print ''.join(output_chars)
        return ''.join(output_chars)

    def Decrypt(self, input_string):
        self.keys.reverse()
        plain_texts = []
        cipher_texts = self.DivideCipherTextsTo64Texts(input_string)
        #CBC Initialization Vector
	self.cbc_iv = self.Des(cipher_texts[0])
        last_code = self.cbc_iv
	for text in cipher_texts[1:]:
            plain_text = self.__XOR(self.Des(text), last_code)
            last_code = text
            plain_texts.append(plain_text)
        plain_text = ''.join(plain_texts)
        
        print plain_text
        output_chars = []
	makeup = int(plain_text[-8:],2)
        for i in range(0, len(plain_text) - 8*makeup - 8, 8):
            output_chars.append(chr(int(plain_text[i:i+8],2)))
        self.keys.reverse()
        return ''.join(output_chars)

'''
if __name__ == "__main__":
    TEST_KEY = "0"*64
    TEST_INPUT = "Hi"
    print TEST_KEY
    dept = DesEncryptor(TEST_KEY)
    print "Construction Done"
    code = dept.Encrypt(TEST_INPUT)
    print code
    print dept.Decrypt(code)
'''
